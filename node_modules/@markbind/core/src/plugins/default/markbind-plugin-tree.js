"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
/**
 * Creates tree-like visualisations.
 * Transforms the content in <tree> tags into corresponding textual representations
 * that are easier to visualise the relationships.
 * A common use case is folder structures visualisations.
 */
const has_1 = __importDefault(require("lodash/has"));
const markdown_it_1 = __importDefault(require("../../lib/markdown-it"));
const _ = { has: has_1.default };
const CSS_FILE_NAME = 'markbind-plugin-tree.css';
const TOKEN = {
    child: '├── ',
    lastChild: '└── ',
    connector: '│   ',
    space: '    ',
};
class TreeNode {
    constructor(content, parent, children, level) {
        this.content = content;
        this.parent = parent;
        this.children = children;
        this.level = level;
    }
    /**
     * Returns true if this node is the last child of its parent.
     * A root node is considered to be the last child.
     * This is used to determine the correct connector to use.
     */
    isLastChild() {
        if (this.parent === null) {
            return true;
        }
        return this.parent.children[this.parent.children.length - 1] === this;
    }
    /**
     * Returns the token to append before the content.
     */
    getPositionalToken() {
        return this.isLastChild() ? TOKEN.lastChild : TOKEN.child;
    }
    /**
     * Determines the level of a line.
     * Every 2 spaces from the start of the line means 1 level.
     * The root node is level 0.
     */
    static levelize(line) {
        var _a;
        const lineMatch = (_a = line.match(/^\s*/)) !== null && _a !== void 0 ? _a : [''];
        return Math.floor(lineMatch[0].length / 2);
    }
    /**
     * Returns formatted TreeNode content.
     * Removes dashes (-), asterisks (*), or plus signs (+) at the beginning of the line
     */
    static getContent(raw) {
        return raw.trim().replace(/^[-+*]\s/, '');
    }
    /**
     * Creates TreeNode objects from the raw text.
     * @param raw - The raw text to parse.
     * @return The dummy root node of the tree.
     */
    static parse(raw) {
        const lines = raw.split('\n').filter(line => line.trim() !== '');
        const rootNode = new TreeNode('.', null, [], -1); // dummy root node
        const prevParentStack = [rootNode];
        let prevLevel = rootNode.level;
        let prevParent = rootNode;
        let prevNode = rootNode;
        lines
            .forEach((line) => {
            const level = TreeNode.levelize(line);
            const content = TreeNode.getContent(line);
            if (level > prevLevel) {
                prevParentStack.push(prevNode);
                prevParent = prevNode;
            }
            else if (level < prevLevel) {
                for (let i = 0; i < prevLevel - level; i += 1) {
                    prevParentStack.pop();
                }
                prevParent = prevParentStack[prevParentStack.length - 1];
            }
            const newNode = new TreeNode(content, prevParent, [], level);
            prevParent.children.push(newNode);
            prevLevel = level;
            prevNode = newNode;
        });
        return rootNode;
    }
    /**
     * Traverses the tree and appends the tokens to the given array.
     * @param currNode - The node to traverse.
     * @param result - The array to append the tokens to.
     */
    static traverse(currNode, result) {
        if (!currNode.children) {
            return;
        }
        if (currNode.parent === null) {
            result.push(markdown_it_1.default.renderInline(`${currNode.content}\n`));
        }
        else {
            const tokens = [
                '\n',
                markdown_it_1.default.renderInline(currNode.content),
                currNode.getPositionalToken(),
            ];
            // computes the strings appended to the content of the TreeNode
            let curr = currNode.parent;
            while (curr && _.has(curr, 'parent.parent')) {
                tokens.push(curr.isLastChild() ? TOKEN.space : TOKEN.connector);
                curr = curr.parent;
            }
            result.push(tokens.reverse().join(''));
        }
        currNode.children.forEach((child) => {
            TreeNode.traverse(child, result);
        });
    }
    /**
     * Returns the TreeNode as a string.
     * This assumes that the node is a root node.
     */
    toString() {
        const treeTokens = [];
        TreeNode.traverse(this, treeTokens);
        return treeTokens.join('');
    }
    /**
     * Returns the rendered tree.
     * @param raw - The raw text to parse.
     */
    static visualize(raw) {
        const dummyRootNode = TreeNode.parse(raw);
        return dummyRootNode.children
            .reduce((prev, curr) => {
            curr.parent = null;
            return prev + curr.toString();
        }, '');
    }
}
module.exports = {
    tagConfig: {
        tree: {
            isSpecial: true,
        },
    },
    getLinks: () => [`<link rel="stylesheet" href="${CSS_FILE_NAME}">`],
    processNode: (_pluginContext, node) => {
        var _a;
        if (node.name !== 'tree') {
            return;
        }
        node.name = 'div';
        node.attribs.class = node.attribs.class ? `${node.attribs.class} tree` : 'tree';
        node.children = (_a = node.children) !== null && _a !== void 0 ? _a : [];
        node.children[0].data = TreeNode.visualize(node.children[0].data);
    },
};
//# sourceMappingURL=markbind-plugin-tree.js.map