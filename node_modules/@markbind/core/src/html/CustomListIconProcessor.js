"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processUlNode = void 0;
const cheerio_1 = __importDefault(require("cheerio"));
const { processIconString } = require('../lib/markdown-it/plugins/markdown-it-icons');
const emojiDictionary = require('../lib/markdown-it/patches/markdown-it-emoji-fixed');
const emojiData = emojiDictionary;
const ICON_ATTRIBUTES = ['icon', 'i-width', 'i-height', 'i-size', 'i-class'];
function classifyIcon(icon) {
    const isEmoji = Object.prototype.hasOwnProperty.call(emojiData, icon);
    return {
        isEmoji,
        unicodeEmoji: isEmoji
            ? emojiData[icon]
            : undefined,
    };
}
function createIconSpan(iconAttrs) {
    const { isEmoji, unicodeEmoji, } = classifyIcon(iconAttrs.icon);
    let spanContent;
    if (isEmoji) {
        spanContent = `<span aria-hidden="true">${unicodeEmoji}</span>`;
    }
    else {
        spanContent = processIconString(iconAttrs.icon);
    }
    let spanNode;
    if (spanContent === null) {
        const img = (0, cheerio_1.default)(`<img src='${iconAttrs.icon}' alt='Icon'>`)
            .css({ width: iconAttrs.width, height: iconAttrs.height, display: 'inline-block' })
            .addClass(iconAttrs.className || '');
        img.append('\u200B');
        spanContent = (0, cheerio_1.default)('<span></span>').append(img).css({
            'padding-bottom': '0.3em',
            'padding-top': '0.3em',
        });
        spanNode = (0, cheerio_1.default)(spanContent).css({ 'font-size': 'unset', 'min-width': '16px' });
    }
    else {
        spanNode = (0, cheerio_1.default)(spanContent).css({ 'font-size': 'unset', 'min-width': '16px' });
        spanNode = spanNode.css({ 'font-size': iconAttrs.size }).addClass(iconAttrs.className || '');
    }
    // Add invisible character to avoid the element from being empty
    spanNode.append('\u200B');
    return spanNode.css({
        'line-height': 'unset',
        'margin-inline-end': '0.35em',
        'align-self': 'flex-start',
        'flex-shrink': '0',
    });
}
function updateNodeStyle(node) {
    const nodeCheerio = (0, cheerio_1.default)(node);
    nodeCheerio.css({
        'list-style-type': 'none',
        'padding-inline-start': '0px',
    });
}
// If an item has a specified icon, that icon will be used for it and for subsequent
// items at that level to prevent duplication of icons attribute declarations.
const getIconAttributes = (node, iconAttrsSoFar) => {
    if ((iconAttrsSoFar === null || iconAttrsSoFar === void 0 ? void 0 : iconAttrsSoFar.icon) === undefined && node.attribs.icon === undefined) {
        return null;
    }
    return {
        icon: node.attribs.icon !== undefined ? node.attribs.icon : iconAttrsSoFar === null || iconAttrsSoFar === void 0 ? void 0 : iconAttrsSoFar.icon,
        width: node.attribs['i-width'] !== undefined ? node.attribs['i-width'] : iconAttrsSoFar === null || iconAttrsSoFar === void 0 ? void 0 : iconAttrsSoFar.width,
        height: node.attribs['i-height'] !== undefined ? node.attribs['i-height'] : iconAttrsSoFar === null || iconAttrsSoFar === void 0 ? void 0 : iconAttrsSoFar.height,
        size: node.attribs['i-size'] !== undefined ? node.attribs['i-size'] : iconAttrsSoFar === null || iconAttrsSoFar === void 0 ? void 0 : iconAttrsSoFar.size,
        className: node.attribs['i-class'] !== undefined ? node.attribs['i-class'] : iconAttrsSoFar === null || iconAttrsSoFar === void 0 ? void 0 : iconAttrsSoFar.className,
    };
};
const deleteAttributes = (node, attributes) => {
    attributes.forEach((attr) => {
        delete node.attribs[attr];
    });
};
function updateLi(node, iconAttributes) {
    if (iconAttributes.icon === undefined)
        return;
    const curLiIcon = getIconAttributes(node, iconAttributes);
    deleteAttributes(node, ICON_ATTRIBUTES);
    // Create a new div and span
    const div = (0, cheerio_1.default)('<div></div>');
    const iconSpan = createIconSpan(curLiIcon);
    div.append((0, cheerio_1.default)(node.children).remove());
    // Append iconSpan and div to the child
    (0, cheerio_1.default)(node).append(iconSpan);
    (0, cheerio_1.default)(node).append(div);
    (0, cheerio_1.default)(node).css({
        display: 'flex',
    });
}
// This function ensures the first item at that level must also be customized.
// If not, the list will be invalidated and default bullets will be used.
// This is to prevent unintentional mixing of standard and customized lists.
// See https://github.com/MarkBind/markbind/pull/2316#discussion_r1255364486 for more details.
function handleLiNode(node, iconAttrValue) {
    var _a;
    if (iconAttrValue.isFirst) {
        iconAttrValue.iconAttrs = getIconAttributes(node);
        iconAttrValue.isFirst = false;
    }
    else if (iconAttrValue.iconAttrs) {
        iconAttrValue.iconAttrs = getIconAttributes(node, iconAttrValue.iconAttrs);
    }
    updateLi(node, (_a = iconAttrValue.iconAttrs) !== null && _a !== void 0 ? _a : {});
}
function processUlNode(node) {
    const nodeAsMbNode = node;
    if (nodeAsMbNode.attribs.isIconListProcessed === 'true') {
        delete nodeAsMbNode.attribs.isIconListProcessed;
        return;
    }
    const iconAttrs = [];
    function dfs(currentNode, level) {
        if (!iconAttrs[level]) {
            iconAttrs[level] = { isFirst: true, iconAttrs: null };
        }
        const ulNode = currentNode;
        const liNodes = ulNode.children.filter(child => child.name === 'li');
        liNodes.forEach((liNode) => {
            var _a;
            const ulChildren = (_a = liNode.children) === null || _a === void 0 ? void 0 : _a.filter(child => child.name === 'ul');
            handleLiNode(liNode, iconAttrs[level]);
            ulChildren === null || ulChildren === void 0 ? void 0 : ulChildren.forEach((ulChildNode) => {
                // Traverse the children if any
                dfs(ulChildNode, level + 1);
                // Insert an `isIconListProcessed` flag attribute to the node.
                if (ulChildNode.attribs) {
                    ulChildNode.attribs.isIconListProcessed = 'true';
                }
            });
        });
        if (iconAttrs[level].iconAttrs !== null) {
            updateNodeStyle(ulNode);
        }
    }
    dfs(node, 0);
}
exports.processUlNode = processUlNode;
//# sourceMappingURL=CustomListIconProcessor.js.map