import { Ignore } from 'ignore';
import { SimpleGit } from 'simple-git';
import Bluebird from 'bluebird';
import { Template as NunjucksTemplate } from 'nunjucks';
import { SiteConfig, SiteConfigPage, SiteConfigStyle } from './SiteConfig';
import { Page } from '../Page';
import { VariableProcessor } from '../variables/VariableProcessor';
import { ExternalManager } from '../External/ExternalManager';
import { SiteLinkManager } from '../html/SiteLinkManager';
import { PluginManager } from '../plugins/PluginManager';
import type { FrontMatter } from '../plugins/Plugin';
type PageCreationConfig = {
    externalScripts: string[];
    frontmatter: FrontMatter;
    layout: string;
    pageSrc: string;
    searchable: boolean;
    faviconUrl?: string;
    glob?: string;
    globExclude?: string;
    title?: string;
};
type AddressablePage = {
    frontmatter: FrontMatter;
    layout: string;
    searchable: string;
    src: string;
    externalScripts?: string[];
    faviconUrl?: string;
    title?: string;
};
type PageGenerationTask = {
    mode: string;
    pages: Page[];
};
type PageGenerationContext = {
    startTime: Date;
    numPagesGenerated: number;
    numPagesToGenerate: number;
    isCompleted: boolean;
};
type DeployOptions = {
    branch: string;
    message: string;
    repo: string;
    remote: string;
    user?: {
        name: string;
        email: string;
    };
};
export declare class Site {
    dev: boolean;
    rootPath: string;
    outputPath: string;
    tempPath: string;
    siteAssetsDestPath: string;
    pageTemplatePath: string;
    pageTemplate: NunjucksTemplate;
    pages: Page[];
    addressablePages: AddressablePage[];
    addressablePagesSource: string[];
    baseUrlMap: Set<string>;
    forceReload: boolean;
    siteConfig: SiteConfig;
    siteConfigPath: string;
    variableProcessor: VariableProcessor;
    pluginManager: PluginManager;
    siteLinkManager: SiteLinkManager;
    backgroundBuildMode: string | boolean;
    stopGenerationTimeThreshold: Date;
    postBackgroundBuildFunc: () => void;
    onePagePath: string;
    currentPageViewed: string;
    currentOpenedPages: string[];
    toRebuild: Set<string>;
    externalManager: ExternalManager;
    layoutManager: any;
    constructor(rootPath: string, outputPath: string, onePagePath: string, forceReload: boolean | undefined, siteConfigPath: string | undefined, dev: any, backgroundBuildMode: boolean, postBackgroundBuildFunc: () => void);
    /**
     * Util Methods
     */
    static rejectHandler(error: unknown, removeFolders: string[]): Promise<void>;
    beforeSiteGenerate(): void;
    /**
     * Changes the site variable of the current page being viewed, building it if necessary.
     * @param normalizedUrl BaseUrl-less and extension-less url of the page
     * @return Boolean of whether the page needed to be rebuilt
     */
    changeCurrentPage(normalizedUrl: string): boolean;
    /**
     * Changes the list of current opened pages
     * @param normalizedUrls Collection of normalized url of pages taken from the clients
     * ordered from most-to-least recently opened
     */
    changeCurrentOpenedPages(normalizedUrls: string[]): void;
    /**
     * Read and store the site config from site.json, overwrite the default base URL
     * if it's specified by the user.
     * @param baseUrl user defined base URL (if exists)
     */
    readSiteConfig(baseUrl?: string): Promise<any>;
    listAssets(fileIgnore: Ignore): string[];
    /**
     * Create a Page object from the site and page creation config.
     */
    createPage(config: PageCreationConfig): Page;
    /**
     * Converts an existing GitHub wiki or docs folder to a MarkBind website.
     */
    convert(): Promise<void>;
    /**
     * Copies over README.md or Home.md to default index.md if present.
     */
    addIndexPage(): Promise<void>;
    /**
     * Adds an about page to site if not present.
     */
    addAboutPage(): Promise<void>;
    /**
     * Adds a footer to default layout of site.
     */
    addDefaultLayoutFiles(): void;
    /**
     * Builds a site navigation file from the directory structure of the site.
     */
    buildSiteNav(): string;
    /**
     * Applies the default layout to all addressable pages by modifying the site config file.
     */
    addDefaultLayoutToSiteConfig(): Promise<void>;
    /**
     * Helper function for addDefaultLayoutToSiteConfig().
     */
    static writeToSiteConfig(config: SiteConfig, configPath: string): Promise<void>;
    static printBaseUrlMessage(): void;
    /**
     * Updates the paths to be traversed as addressable pages and returns a list of filepaths to be deleted
     */
    updateAddressablePages(): string[];
    getPageGlobPaths(page: SiteConfigPage, pagesExclude: string[]): string[];
    /**
     * Collects the paths to be traversed as addressable pages
     */
    collectAddressablePages(): void;
    /**
     * Collects the base url map in the site/subsites
     */
    collectBaseUrl(): void;
    /**
     * Set up the managers used with the configurations.
     */
    buildManagers(): void;
    /**
     * Collects the user defined variables map in the site/subsites
     */
    collectUserDefinedVariablesMap(): void;
    /**
     * Collects the user defined variables map in the site/subsites
     * if there is a change in the variables file
     * @param filePaths array of paths corresponding to files that have changed
     */
    collectUserDefinedVariablesMapIfNeeded(filePaths: string[]): boolean;
    /**
     * Generate the website.
     * @param baseUrl user defined base URL (if exists)
     */
    generate(baseUrl: string | undefined): Promise<any>;
    /**
     * Helper function for generate().
     */
    calculateBuildTimeForGenerate(startTime: Date, lazyWebsiteGenerationString: string): void;
    /**
     * Build all pages of the site
     */
    buildSourceFiles(): Promise<void>;
    /**
     * Adds all pages except the viewed pages to toRebuild, flagging them for lazy building later.
     */
    lazyBuildAllPagesNotViewed(viewedPages: string | string[]): Promise<void>;
    /**
     * Only build landing page of the site, building more as the author goes to different links.
     */
    lazyBuildSourceFiles(): Promise<void>;
    /**
     * Helper function for lazyBuildSourceFiles().
     */
    copyLazySourceFiles(): Promise<void>;
    _rebuildAffectedSourceFiles(filePaths: string | string[]): Promise<void>;
    _rebuildPagesBeingViewed(normalizedUrls: string[]): Promise<void>;
    /**
     * Helper function for _rebuildPagesBeingViewed().
     */
    static calculateBuildTimeForRebuildPagesBeingViewed(startTime: Date): void;
    _backgroundBuildNotViewedFiles(): Promise<void>;
    /**
     * Generates pages that are marked to be built/rebuilt.
     * @returns A Promise that resolves once all pages are generated.
     */
    generatePagesMarkedToRebuild(): Promise<boolean>;
    _rebuildSourceFiles(): Promise<void>;
    /**
     * Helper function for _rebuildSourceFiles().
     */
    rebuildRequiredPages(): Promise<void>;
    _buildMultipleAssets(filePaths: string | string[]): Promise<void>;
    _removeMultipleAssets(filePaths: string | string[]): Promise<void>;
    buildAssets(): Promise<void>;
    reloadSiteConfig(): Promise<void>;
    /**
     * Handles the rebuilding of modified pages
     */
    handlePageReload(oldAddressablePages: AddressablePage[], oldPagesSrc: string[], oldSiteConfig: SiteConfig): Promise<void>;
    /**
     * Creates new pages and replaces the original pages with the updated version
     */
    updatePages(pagesToUpdate: AddressablePage[]): void;
    /**
     * Handles the reloading of ignore attributes
     */
    handleIgnoreReload(oldIgnore: string[]): Promise<void>;
    /**
     * Handles the reloading of the style attribute if it has been modified
     */
    handleStyleReload(oldStyle: SiteConfigStyle): Promise<void>;
    /**
     * Checks if a specified file path is a dependency of a page
     * @param filePath file path to check
     * @returns whether the file path is a dependency of any of the site's pages
     */
    isDependencyOfPage(filePath: string): boolean;
    /**
     * Checks if a specified file path satisfies a src or glob in any of the page configurations.
     * @param filePath file path to check
     * @returns whether the file path is satisfies any glob
     */
    isFilepathAPage(filePath: string): boolean;
    getFavIconUrl(): string | undefined;
    /**
     * Maps an array of addressable pages to an array of Page object
     */
    mapAddressablePagesToPages(addressablePages: AddressablePage[], faviconUrl: string | undefined): void;
    /**
     * Creates and returns a new Page with the given page config details and favicon url
     * @param page config
     * @param faviconUrl of the page
     */
    createNewPage(page: AddressablePage, faviconUrl: string | undefined): Page;
    stopOngoingBuilds(): void;
    /**
     * Runs the supplied page generation tasks according to the specified mode of each task.
     * A page generation task can be a sequential generation or an asynchronous generation.
     * @param pageGenerationTasks Array of page generation tasks
     * @returns A Promise that resolves to a boolean which indicates whether the generation
     * ran to completion
     */
    runPageGenerationTasks(pageGenerationTasks: PageGenerationTask[]): Promise<boolean>;
    /**
     * Generate pages sequentially. That is, the pages are generated
     * one-by-one in order.
     * @param pages Pages to be generated
     * @param progressBar Progress bar of the overall generation process
     * @returns A Promise that resolves to a boolean which indicates whether the generation
     * ran to completion
     */
    generatePagesSequential(pages: Page[], progressBar: any): Promise<boolean>;
    /**
     * Creates the supplied pages' page generation promises at a throttled rate.
     * This is done to avoid pushing too many callbacks into the event loop at once. (#1245)
     * @param pages Pages to be generated
     * @param progressBar Progress bar of the overall generation process
     * @returns A Promise that resolves to a boolean which indicates whether the generation
     * ran to completion
     */
    generatePagesAsyncThrottled(pages: Page[], progressBar: any): Promise<boolean>;
    /**
     * Helper function for generatePagesAsyncThrottled().
     */
    generateProgressBarStatus(progressBar: any, context: PageGenerationContext, pageGenerationQueue: (() => Promise<void>)[], resolve: ((arg0: boolean) => any)): void;
    /**
     * Renders all pages specified in site configuration file to the output folder
     */
    generatePages(): Promise<boolean>;
    /**
     * Renders only the starting page for lazy loading to the output folder.
     */
    generateLandingPage(): Promise<void>;
    regenerateAffectedPages(filePaths: string[]): Promise<void>;
    /**
     * Helper function for regenerateAffectedPages().
     */
    calculateBuildTimeForRegenerateAffectedPages(startTime: Date): void;
    /**
     * Copies Font Awesome assets to the assets folder
     */
    copyFontAwesomeAsset(): Promise<void>;
    /**
     * Copies Octicon assets to the assets folder
     */
    copyOcticonsAsset(): Promise<void>;
    /**
     * Copies Google Material Icons assets to the assets folder
     */
    copyMaterialIconsAsset(): Promise<void>;
    /**
     * Copies core-web bundles and external assets to the assets output folder
     */
    copyCoreWebAsset(): Promise<void[]>;
    /**
     * Copies bootstrapTheme to the assets folder if a valid bootstrapTheme is specified
     * @param isRebuild only true if it is a rebuild
     */
    copyBootstrapTheme(isRebuild: boolean): Promise<void> | ((...args: any[]) => void);
    /**
     * Writes the site data to siteData.json
     * @param verbose Flag to emit logs of the operation
     */
    writeSiteData(verbose?: boolean): Promise<void>;
    deploy(ciTokenVar: string | boolean): Promise<string | null>;
    /**
     * Helper function for deploy(). Returns the ghpages link where the repo will be hosted.
     */
    generateDepUrl(ciTokenVar: boolean | string, defaultDeployConfig: DeployOptions): Promise<string | null>;
    /**
     * Helper function for deploy(). Set the options needed to be used by ghpages.publish.
     */
    getDepOptions(ciTokenVar: boolean | string, defaultDeployConfig: DeployOptions, publish: (basePath: string, options: DeployOptions) => Bluebird<unknown>): Promise<DeployOptions>;
    /**
     * Extract repo slug from user-specified repo URL so that we can include the access token
     */
    static extractRepoSlug(repo: string, ciRepoSlug: string | undefined): string | undefined;
    /**
     * Helper function for deploy().
     */
    static getDepUrl(options: DeployOptions): Promise<string | null>;
    /**
     * Gets the deployed website's url, returning null if there was an error retrieving it.
     */
    static getDeploymentUrl(git: SimpleGit, options: DeployOptions): Promise<string | null>;
    _setTimestampVariable(): void;
    /**
     * Build/copy assets that are specified in filePaths
     * @param filePaths a single path or an array of paths corresponding to the assets to build
     */
    buildAsset: (this: any, arg: unknown) => Bluebird<unknown>;
    /**
     * Remove assets that are specified in filePaths
     * @param filePaths a single path or an array of paths corresponding to the assets to remove
     */
    removeAsset: (this: any, arg: unknown) => Bluebird<unknown>;
    rebuildPagesBeingViewed: (this: any, arg: unknown) => Bluebird<unknown>;
    /**
     * Rebuild pages that are affected by changes in filePaths
     * @param filePaths a single path or an array of paths corresponding to the files that have changed
     */
    rebuildAffectedSourceFiles: (this: any, arg: unknown) => Bluebird<unknown>;
    /**
     * Rebuild all pages
     */
    rebuildSourceFiles: () => Bluebird<unknown>;
    /**
     * Builds pages that are yet to build/rebuild in the background
     */
    backgroundBuildNotViewedFiles: () => Bluebird<unknown>;
}
export {};
//# sourceMappingURL=index.d.ts.map